---
description: >-
 Understanding CORS
title:  Same-Origin Policy and CORS           # Add title here
date: 2024-01-02 08:00:00 -0600                           # Change the date to match completion date
categories: [20 Web, Same-Origin Policy and CORS]                     # Change Templates to Writeup
tags: [web, same-origin policy, cors]     # TAG names should always be lowercase; replace template with writeup, and add relevant tags
show_image_post: false                                    # Change this to true
#image: /assets/img/machine-0-infocard.png                # Add infocard image here for post preview image
---

### Same-Origin Policy and CORS

There are three key conecpts to understand CORS:

- Origins and the Same-Origin Policy (SOP)
- Cross-Origin Resource Sharing (CORS)
- Sending Requests Between Origins

Modern web applications often use resources and data from multiple domains or web sites. Web applications load images, fonts, and even _JavaScript_ from external domains. When an HTML page or other resource on one domain instructs a browser to load content from another domain, the resulting request is a _cross-origin_ request.

Browsers implement the _Same-Origin Policy_ (SOP),[1](https://en.wikipedia.org/wiki/Same-origin_policy) a protective mechanism that limits how JavaScript code can interact with such requests and their responses. Developers can use _Cross-Origin Resource Sharing_ (CORS)[2](https://en.wikipedia.org/wiki/Cross-origin_resource_sharing) to selectively relax the SOP on their applications.

_JSON with Padding_ (JSONP)[3](https://en.wikipedia.org/wiki/JSONP) is another technique for bypassing the SOP, but it has multiple security concerns and has largely been replaced by CORS.

We will explore these mechanisms and their security implications. We will also cover how to send cross-origin requests in JavaScript.

### Origins and the Same-Origin Policy (SOP)

The first concept needed to understand CORS is Same-Origin Policy, two considerations are:

1. Understand what an origin is in the context of web applications
2. Understand the Same-Origin Policy

In the context of web applications, an origin is a subset of a URL. It is the combination of a _protocol_,[1](https://en.wikipedia.org/wiki/Communication_protocol) a _hostname_, [2](https://en.wikipedia.org/wiki/Hostname) and a _port number_.[3](https://en.wikipedia.org/wiki/Port_(computer_networking))

Let's review a sample URL and determine its origin.

```bash
URL: https://www.example.com/blog/
Origin:  https://www.example.com
```

Our sample URL's protocol is _HTTPS_. Its domain is **www.example.com**. The URL does not include an explicit port number, so its origin uses the default port number of HTTPS (443). Notice that the origin includes the entire domain name, including the "www" subdomain, but does not include the path value (/blog).

We can also use JavaScript to derive the origin of a URL. The _URL_[4](https://developer.mozilla.org/en-US/docs/Web/API/URL) object includes an _origin_[5](https://developer.mozilla.org/en-US/docs/Web/API/URL/origin) property that returns the URL's origin.

Let's try it out. We'll need to open our web browser and then open its JavaScript Console with [F12]. We can then declare a new _URL_ object by typing **u = new URL("https://www.example.com/blog")** and pressing [Enter]. We can then check the URL's origin by typing **u.origin** and pressing [Enter].

![Creating a URL object and checking its origin](/assets/img/Pasted-image-20240102190855.png)

The _origin_ property returned **https://www.example.com**.

We can also read the _origin_[6](https://developer.mozilla.org/en-US/docs/Web/API/origin) property on the global scope after loading a web page. In our browser's JavaScript console, calling _self.origin_ is essentially the same as calling _window.origin_. Both properties will return the origin of the currently loaded web page.

Now that we understand origins, let's review the _Same-origin Policy_ (SOP).

### Same-Origin Policy (SOP)

The SOP is a protective mechanism that web browsers implement that prevents resources loaded on one origin from accessing resources loaded from a different origin. A resource can be an image, HTML, data, JSON, etc.

Without the SOP, the web would be a much more dangerous place, allowing any website we visit to read our emails, check our bank balances, and view other information from our logged-in sessions.

Instead, SOP allows cross-origin requests, but blocks JavaScript from accessing the results of the request. This might seem confusing since plenty of websites have images, scripts, and other resources loaded from third-party origins.

Let's consider an example in which **https://foo.com/latest** uses JavaScript to access multiple resources. Some resources might be on the same domain, but on a different page. Others might be on a completely different domain. Not all these resources will successfully load.

|URL|RESULT|REASON|
|---|---|---|
|https://foo.com/myInfo|Allowed|Same Origin|
|**http:**//foo.com/users.json|Blocked|Different Scheme and Port|
|https://**api**.foo.com/info|Blocked|Different Domain|
|https://foo.com:8443/files |Blocked|Different Port|
|https://**bar**.com/analytics.js|Blocked|Different Domain|

In the examples listed in the table all of the requests would be sent, but the JavaScript on **https://foo.com/latest** would not be able to read the response of those marked as "Blocked".

How do web pages embed images or other content from different domains? SOP enforcement depends on the type of cross-origin request, which can be divided into embeds, writes, and reads.

With the continued use of _content delivery networks_ (CDN),[1](https://en.wikipedia.org/wiki/Content_delivery_network) embeds might be the most common type of cross-origin interaction. Many web applications embed JavaScript files, images, fonts, and videos from CDNs or other external domains. It is important to note that embedding JavaScript in this way effectively bypasses the SOP. In other words, the embedded JavaScript code would be able to read the contents of the embedding page.

In other words, if we were to visit the example **https://bar.com/analytics.js** directly, it could not access the contents of **https://foo.com/latest**. However, if **https://foo.com/latest** loads the contents of **https://bar.com/analytics.js** with a _<script></script>_ tag, the JavaScript code would have access to the page contents.

Cross-origin writes are links, redirects, and form submissions. We can think of writes as one-way traffic. One origin can initiate a write to a different origin, but it cannot access the response. For example, **https://foo.com/latest** can have a form that sends a POST request to **https://bar.com**, but SOP will block JavaScript on **https://foo.com/latest** from accessing the response. Accessing the response would constitute a read interaction, which are all typically blocked by SOP.

While this page focuses on SOP and CORS, it is worth mentioning _cross-site request forgery_ (CSRF)[2](https://en.wikipedia.org/wiki/Cross-site_request_forgery) attacks, which exploit SOP allowing cross-origin writes. Attackers use CSRF attacks to perform actions as the victim user. For example, an attacker might embed a hidden form in a page that automatically submits to perform some action, such as changing a password, creating a new user, or otherwise manipulating the user's account and application access.

CSRF vulnerabilities have become less common in recent years since many frameworks include CSRF protections. Web applications can also set the _SameSite_[3](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite) attribute on cookies to indicate how browsers should handle the cookies on cross-origin requests. If a cookie has the _SameSite_ attribute set to _Lax_, browsers will not send the cookie on cross-origin requests.

CSRF attacks usually require victims to have an active, authenticated session on the target site. If the browser doesn't send session cookies on the CSRF request, the attack will typically fail. Most browsers will default cookies to _SameSite=Lax_ if no other SameSite value is set.[4](https://scotthelme.co.uk/csrf-is-really-dead/)

Web applications can use Cross-origin Resource Sharing to enable cross-domain reads.

### Cross-origin Resource Sharing (CORS)

Now that we understand what Same Origin Policy is we can deep dive into CORS and:

1. Understand the basics of Cross-origin Resource Sharing
2. Understand what headers are available on CORS requests
3. Understand how web servers enable CORS
4. Understand the basic security concerns of enabling CORS
