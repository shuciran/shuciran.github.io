---
description: >-
 Understanding CORS
title:  Same-Origin Policy and CORS           # Add title here
date: 2024-01-02 08:00:00 -0600                           # Change the date to match completion date
categories: [20 Web, Same-Origin Policy and CORS]                     # Change Templates to Writeup
tags: [web, same-origin policy, cors]     # TAG names should always be lowercase; replace template with writeup, and add relevant tags
show_image_post: false                                    # Change this to true
#image: /assets/img/machine-0-infocard.png                # Add infocard image here for post preview image
---

### Same-Origin Policy and CORS

There are three key conecpts to understand CORS:

- Origins and the Same-Origin Policy (SOP)
- Cross-Origin Resource Sharing (CORS)
- Sending Requests Between Origins

Modern web applications often use resources and data from multiple domains or web sites. Web applications load images, fonts, and even _JavaScript_ from external domains. When an HTML page or other resource on one domain instructs a browser to load content from another domain, the resulting request is a _cross-origin_ request.

Browsers implement the _Same-Origin Policy_ (SOP),[1](https://en.wikipedia.org/wiki/Same-origin_policy) a protective mechanism that limits how JavaScript code can interact with such requests and their responses. Developers can use _Cross-Origin Resource Sharing_ (CORS)[2](https://en.wikipedia.org/wiki/Cross-origin_resource_sharing) to selectively relax the SOP on their applications.

_JSON with Padding_ (JSONP)[3](https://en.wikipedia.org/wiki/JSONP) is another technique for bypassing the SOP, but it has multiple security concerns and has largely been replaced by CORS.

We will explore these mechanisms and their security implications. We will also cover how to send cross-origin requests in JavaScript.

### Origins and the Same-Origin Policy (SOP)

The first concept needed to understand CORS is Same-Origin Policy, two considerations are:

1. Understand what an origin is in the context of web applications
2. Understand the Same-Origin Policy

In the context of web applications, an origin is a subset of a URL. It is the combination of a _protocol_,[1](https://en.wikipedia.org/wiki/Communication_protocol) a _hostname_, [2](https://en.wikipedia.org/wiki/Hostname) and a _port number_.[3](https://en.wikipedia.org/wiki/Port_(computer_networking))

Let's review a sample URL and determine its origin.

```bash
URL: https://www.example.com/blog/
Origin:  https://www.example.com
```

Our sample URL's protocol is _HTTPS_. Its domain is **www.example.com**. The URL does not include an explicit port number, so its origin uses the default port number of HTTPS (443). Notice that the origin includes the entire domain name, including the "www" subdomain, but does not include the path value (/blog).

We can also use JavaScript to derive the origin of a URL. The _URL_[4](https://developer.mozilla.org/en-US/docs/Web/API/URL) object includes an _origin_[5](https://developer.mozilla.org/en-US/docs/Web/API/URL/origin) property that returns the URL's origin.

Let's try it out. We'll need to open our web browser and then open its JavaScript Console with [F12]. We can then declare a new _URL_ object by typing **u = new URL("https://www.example.com/blog")** and pressing [Enter]. We can then check the URL's origin by typing **u.origin** and pressing [Enter].

![Creating a URL object and checking its origin](/assets/img/Pasted-image-20240102190855.png)

The _origin_ property returned **https://www.example.com**.

We can also read the _origin_[6](https://developer.mozilla.org/en-US/docs/Web/API/origin) property on the global scope after loading a web page. In our browser's JavaScript console, calling _self.origin_ is essentially the same as calling _window.origin_. Both properties will return the origin of the currently loaded web page.

Now that we understand origins, let's review the _Same-origin Policy_ (SOP).

### Same-Origin Policy (SOP)

The SOP is a protective mechanism that web browsers implement that prevents resources loaded on one origin from accessing resources loaded from a different origin. A resource can be an image, HTML, data, JSON, etc.

Without the SOP, the web would be a much more dangerous place, allowing any website we visit to read our emails, check our bank balances, and view other information from our logged-in sessions.

Instead, SOP allows cross-origin requests, but blocks JavaScript from accessing the results of the request. This might seem confusing since plenty of websites have images, scripts, and other resources loaded from third-party origins.

Let's consider an example in which **https://foo.com/latest** uses JavaScript to access multiple resources. Some resources might be on the same domain, but on a different page. Others might be on a completely different domain. Not all these resources will successfully load.

|URL|RESULT|REASON|
|---|---|---|
|https://foo.com/myInfo|Allowed|Same Origin|
|**http:**//foo.com/users.json|Blocked|Different Scheme and Port|
|https://**api**.foo.com/info|Blocked|Different Domain|
|https://foo.com:8443/files |Blocked|Different Port|
|https://**bar**.com/analytics.js|Blocked|Different Domain|

In the examples listed in the table all of the requests would be sent, but the JavaScript on **https://foo.com/latest** would not be able to read the response of those marked as "Blocked".

How do web pages embed images or other content from different domains? SOP enforcement depends on the type of cross-origin request, which can be divided into embeds, writes, and reads.

With the continued use of _content delivery networks_ (CDN),[1](https://en.wikipedia.org/wiki/Content_delivery_network) embeds might be the most common type of cross-origin interaction. Many web applications embed JavaScript files, images, fonts, and videos from CDNs or other external domains. It is important to note that embedding JavaScript in this way effectively bypasses the SOP. In other words, the embedded JavaScript code would be able to read the contents of the embedding page.

In other words, if we were to visit the example **https://bar.com/analytics.js** directly, it could not access the contents of **https://foo.com/latest**. However, if **https://foo.com/latest** loads the contents of **https://bar.com/analytics.js** with a _<script></script>_ tag, the JavaScript code would have access to the page contents.

Cross-origin writes are links, redirects, and form submissions. We can think of writes as one-way traffic. One origin can initiate a write to a different origin, but it cannot access the response. For example, **https://foo.com/latest** can have a form that sends a POST request to **https://bar.com**, but SOP will block JavaScript on **https://foo.com/latest** from accessing the response. Accessing the response would constitute a read interaction, which are all typically blocked by SOP.

While this page focuses on SOP and CORS, it is worth mentioning _cross-site request forgery_ (CSRF)[2](https://en.wikipedia.org/wiki/Cross-site_request_forgery) attacks, which exploit SOP allowing cross-origin writes. Attackers use CSRF attacks to perform actions as the victim user. For example, an attacker might embed a hidden form in a page that automatically submits to perform some action, such as changing a password, creating a new user, or otherwise manipulating the user's account and application access.

CSRF vulnerabilities have become less common in recent years since many frameworks include CSRF protections. Web applications can also set the _SameSite_[3](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite) attribute on cookies to indicate how browsers should handle the cookies on cross-origin requests. If a cookie has the _SameSite_ attribute set to _Lax_, browsers will not send the cookie on cross-origin requests.

CSRF attacks usually require victims to have an active, authenticated session on the target site. If the browser doesn't send session cookies on the CSRF request, the attack will typically fail. Most browsers will default cookies to _SameSite=Lax_ if no other SameSite value is set.[4](https://scotthelme.co.uk/csrf-is-really-dead/)

Web applications can use Cross-origin Resource Sharing to enable cross-domain reads.

### Cross-origin Resource Sharing (CORS)

Now that we understand what Same Origin Policy is we can deep dive into CORS and:

1. Understand the basics of Cross-origin Resource Sharing
2. Understand what headers are available on CORS requests
3. Understand how web servers enable CORS
4. Understand the basic security concerns of enabling CORS

### Exploring CORS

We need to create an entry in our **/etc/hosts** file so that we can access the _SOP and CORS Sandbox_ VM at **http://sop-cors-sandbox**.

```
kali@kali:~$ sudo mousepad /etc/hosts

kali@kali:~$ cat /etc/hosts
127.0.0.1       localhost
127.0.1.1       kali

# The following lines are desirable for IPv6 capable hosts
::1     localhost ip6-localhost ip6-loopback
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters

192.168.50.155  sop-cors-sandbox
```

For now, we only need to start the SOP and CORS Sandbox machine listed below and update **/etc/hosts** with the corresponding IP address on our Kali machine before starting our work.

In its simplest terms, CORS instructs a browser to allow certain origins to access resources from the server. It allows web applications to intentionally loosen SOP restrictions on themselves by specifying which external domains can access resources and how those domains can access the resources. Web applications can enable CORS by setting certain headers on server responses.

Remember, the SOP blocks JavaScript and our browsers from accessing cross-origin resources, but it does not block the outgoing requests for such resources. With CORS enabled on the remote server, JavaScript running on the application initiating the request can then access the response.

For example, to allow **https://foo.com** to load data from **https://api.foo.com**, the API endpoint must have a CORS header allowing the **https://foo.com** origin. If the API endpoint does not enable CORS, then our browser will enforce the SOP and block JavaScript from accessing the response.

Let's explore an example of CORS in the SOP and CORS Sandbox VM. The VM has two web applications. One application runs on port 80 and the other runs on port 8080. Let's start by browsing to the application on port 80 at **http://sop-cors-sandbox/**.

![Figure 2: SOP and CORS Sandbox](https://offsec-platform-prod.s3.amazonaws.com/offsec-courses/SSD-100/images/sop_cors/32d01fe62855e244b48a32e5becc559b-sop_cors_sandbox_01.png)

This web page has two buttons. Both buttons will trigger JavaScript code that will check our status in the secondary web application running on port 8080. Our initial status is "unknown". Before we do anything else, let's open our browser's development tools with + and then click _Network_ so that we can inspect the requests sent by this page.

![Figure 3: Developer Tools - Network tab](https://offsec-platform-prod.s3.amazonaws.com/offsec-courses/SSD-100/images/sop_cors/541294980ff4d2adb0cabdad32804ff3-sop_cors_sandbox_02.png)

Next, let's click the _Refresh_ button.

![Figure 4: Status: Not Logged In](https://offsec-platform-prod.s3.amazonaws.com/offsec-courses/SSD-100/images/sop_cors/295acdff3e31aeaa3d32d162bf7aa52a-sop_cors_sandbox_03.png)

The page sent a request to port 8080 and updated our status to "Not logged in". For now, we are just exploring the behavioral differences between SOP and CORS. With that in mind, let's click the _Refresh without CORS_ button.

![Figure 5: Non-CORS Request](https://offsec-platform-prod.s3.amazonaws.com/offsec-courses/SSD-100/images/sop_cors/118c6b2508edc6fbf62ee0741a963cd1-sop_cors_sandbox_04.png)

The page didn't change our status, but the _Network_ tab shows the request's status as blocked. If we switch to the _Console_ tab, we get a more verbose message.

![Figure 6: Cross-Origin Request Blocked](https://offsec-platform-prod.s3.amazonaws.com/offsec-courses/SSD-100/images/sop_cors/0ef75dddf0230475433aa68fff1b73de-sop_cors_sandbox_05.png)

The third error message states "The Same Origin Policy disallows reading the remote resource...". Applications must explicitly enable CORS to bypass the same-origin policy. Even though both applications are running on the same domain, the applications have different origins since they are running on different ports.

Let's clear the console output by clicking on the trash can icon in the upper left corner of the _Console_ tab and then switch back to the _Network_ tool.

Next, let's review an example of the page using CORS to access data from a different origin. We'll open a new tab in our browser and navigate to **http://sop-cors-sandbox:8080/**.

![Figure 7: Login Page](https://offsec-platform-prod.s3.amazonaws.com/offsec-courses/SSD-100/images/sop_cors/978f48e905319a52d978247586ab3edc-sop_cors_sandbox_06.png)

We can log in with the username "student" and the password "studentlab".

![Figure 8: Today's Secret Code](https://offsec-platform-prod.s3.amazonaws.com/offsec-courses/SSD-100/images/sop_cors/194f9f7dfaf39a0eabd2a3a14730e239-sop_cors_sandbox_07.png)

Once we are logged in, we can view today's secret code. Let's switch back to the browser tab with the sandbox page and click the _Refresh_ button.

![Figure 9: Accessing the Secret Code from a different origin](https://offsec-platform-prod.s3.amazonaws.com/offsec-courses/SSD-100/images/sop_cors/e5456a0ef1a457ad206ba09168bc013b-sop_cors_sandbox_08.png)

The CORS request returned an HTTP 200 response, and the page displayed the secret code. This basic example illustrates how one origin (the sandbox application on port 80) can access data from a different origin that implements CORS (the application on port 8080). The application on port 80 was able to read the responses of the CORS requests sent to port 8080 and display the contents within the web page. If the web application on port 80 contained any malicious JavaScript code, that code would also be able to read the CORS responses and exfiltrate the data or perform actions on behalf of the user logged in to port 8080.

While both applications in this example are running on the same host, they have different origins. This example would be functionally the same if the two applications were running on different servers.

Next, we'll review the HTTP methods and headers that CORS uses.